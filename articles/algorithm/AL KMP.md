---
title: KMP 算法详解
tags: 算法
---

## 什么是 KMP, 解决了什么问题

KMP 是三个人发明的算法, 解决的问题是: `a 字符串在 b 字符串的位置`, 就是 js 的 String.prototype.indexOf 方法

比如:

```js
let a = 'aaab'
let b = 'aaaaaaaaaaab'

//用原生方法就是 
b.indexOf(a) // 8
```



## 易懂方法

明白了问题以后, 我们可以很正常的写出一种方案

```js
const myIndexOf = (str1, str2) => {
    if (!str1 || !str2) return -1
    if (str1.length < str2.length) return -1 // str1 包含 str2
    for (let i = 0, len1 = str1.length; i < len1; i++) {
        if (str1[i] === str2[0]) { // 找到了头部, 开始匹配
            for (let j = 0, len2 = str2.length; j < len2; j++) { // 循环 str2
                if (str1[i + j] === str2[j]) {
                    if (j === len2 - 1) return [i, j]
                } else {
                    break
                }
            }
        }
    }
} // O(n * m)
```

简单来说就是一个一个的字符匹配

对于上面的例子来说就是

```js
a === a
a === a
a === a
a !== b // 在这里不等, 停止匹配, 换下一个 a
// ...
```

可是这样的 时间复杂度就是 O(n * m), 还是一个比较费时的操作

## KMP

### Next 数组的求解

在讲解 KMP 之前, 先了解 **最长前缀和最长后缀相等** 的问题

比如 'abcabcx' , 在 x 位置的 最长前缀和最长后缀相等的长度为 3, 这个字符串除去 x, 前面和后面相等的最长长度就是 3

abc === abc, 我们需要求出每一个位置的 **最长前缀和最长后缀相等**

对于 abc , 在 c 位置的 **最长前缀和最长后缀相等** 为 0, 不能包括 ab

举例

```js
let a = 'abababcb'
// 对于每一个位置都会有一个最长前缀和最长后缀相等
// 这个字符串的前后缀数组为 [-1, 0, 0, 0, 1, 2, 3, 0] 前两位 人为规定为 [-1, 0]
// 这个特殊的数组就是 next 数组, KMP 里面的关键部分
```

那我们写出来这个函数

```js
// 命名为 next 数组
const getNextArr = str => {
    if (str.length < 2) return [-1]
    let next = []
    next.length = str.length
    next[0] = -1, next[1] = 0
    let i = 2, cn = 0
    while (i < str.length) {
        if (str[i - 1] === str[cn]) {
            next[i++] = ++cn
        } else if (cn > 0) { 
            cn = next[cn]
        } else {
            next[i++] = 0
        }
    }
    return next
}
```

这个函数还是很精妙的, 举例来说吧

```js
let str = 'abcabcxabcabczy'
```

| 第 n 次循环 | i 的值 | cn 的值 | 解释                                                         | next数组的状态                                 |
| ----------- | ------ | ------- | ------------------------------------------------------------ | ---------------------------------------------- |
| 1           | 2      | 0       | 比较 'b' === 'a'                                             | [-1, 0, 0]                                     |
| 2           | 3      | 0       | 比较 'c' === 'a'                                             | [-1, 0, 0, 0]                                  |
| 3           | 4      | 0       | 比较 'a' === 'a'                                             | [-1, 0, 0, 0, 1]                               |
| 4           | 5      | 1       | 比较 'b' === 'b'                                             | [-1, 0, 0, 0, 1, 2]                            |
| 5           | 6      | 2       | 比较 'c' === 'c'                                             | [-1, 0, 0, 0, 1, 2, 3]                         |
| 6           | 7      | 3       | 比较 'x' === 'a' <br/>这里要注意 cn 是怎么变的, cn 变成了 0  | [-1, 0, 0, 0, 1, 2, 3]                         |
| 7           | 7      | 0       | 比较 'x' === 'a' (第一个a)                                   | [-1, 0, 0, 0, 1, 2, 3, 0]                      |
| 8           | 8      | 0       | 比较 'a' === 'a'                                             | [-1, 0, 0, 0, 1, 2, 3, 0, 1]                   |
| 9           | 9      | 1       | 比较 'b' === 'b'                                             | [-1, 0, 0, 0, 1, 2, 3, 0, 1, 2]                |
| 10          | 10     | 2       | 比较 'c' === 'c'                                             | [-1, 0, 0, 0, 1, 2, 3, 0, 1, 2, 3]             |
| 11          | 11     | 3       | 比较 'a' === 'a'                                             | [-1, 0, 0, 0, 1, 2, 3, 0, 1, 2, 3, 4]          |
| 12          | 12     | 4       | 比较 'b' === 'b'                                             | [-1, 0, 0, 0, 1, 2, 3, 0, 1, 2, 3, 4, 5]       |
| 13          | 13     | 5       | 比较 'c' === 'c'                                             | [-1, 0, 0, 0, 1, 2, 3, 0, 1, 2, 3, 4, 5, 6]    |
| 14          | 14     | 6       | 比较 'z' === 'x' <br />注意这里不等了, cn 怎么变的<br />变成了 next[6] 就是 3 | [-1, 0, 0, 0, 1, 2, 3, 0, 1, 2, 3, 4, 5, 6]    |
| 15          | 14     | 3       | 比较 'z' === 'a' <br />又不等, cn 变成了 0                   | [-1, 0, 0, 0, 1, 2, 3, 0, 1, 2, 3, 4, 5, 6]    |
| 16          | 14     | 0       | 比较 'z' === 'a' <br />还是不等, 说明前缀为 0                | [-1, 0, 0, 0, 1, 2, 3, 0, 1, 2, 3, 4, 5, 6, 0] |

简单理解呢就是如果相等, 一直比下去, **如果不相等, 找到 cn 对应的位置前缀比较, 如此循环**

真的很奇妙, 你品, 你细品



### 主体函数

搞懂了 next 数组获取的方法后, 再写出来  KMP 主体函数

```js
const getIndexOf = (str1, str2) => {
    // 寻找 str2 在 str1的位置
    if (!str1 || !str2 || str1.length < 1 || str1.length < str2.length) return -1
    let i1 = 0, i2 = 0 // 两个字符串的下标
    const next = getNext(str2) // 得到 next 数组
    while (i1 < str1.length && i2 < str2.length) {
        if (str1[i1] === str2[i2]) {
            i1 ++
            i2 ++
        } else if (next[i2] === -1) {
            // 这个表示开头配不上, str1换位置
            i1 ++
        } else {
            i2 = next[i2]
        }
    }
    return i2 === str2.length ? i1 - i2 : -1 // 如果str2已经划过了str1, 则表示匹配成功
}
```

这里, 需要讲解一下

前缀数组在这里是怎么用的

比如

```js
let a = 'aaaaaaaaaaabaaaa'
let b = 'aaaab'
```

我们可以获得 b 的 next 数组为 [-1, 0, 1, 2, 3]

在比较的过程中, 对比到 a[4] !== b[4] 怎么变, i2怎么变, i2 变成了 3, 就是 i2 从 0 开始匹配没匹配成功, i2 变成了3, i1 这时候是 4, 比较 a === a, 如果是老方法, 还需要将 i1 设为 1 重新比较

KMP 则不需要, 这样一直比下去, 一直等到最后, 如果 b 划过了 a, 则说明 a 里面有 b, 并且最后的位置 i1 - i2 就是起始位置

KMP 就是这样加速的

