## 理论基础

### 常见基础题目

1. 斐波那契数列/爬楼梯
2. 背包问题
3. 打家劫舍
4. 股票问题
5. 子序列问题 / 编辑距离问题
6. 区间dp/概率dp(拔尖)



### 动态规划必须搞懂的

> 动态规划就是初始一个dp数组, 遍历dp数组, 根据前面的状态推导后面的状态, 直到达到题意

1. dp数组含义
2. 递推公式 (状态转移方程)
3. dp数组如何初始化
4. 遍历顺序
5. 打印dp数组(debug)



## 题目

### 1. [509. 斐波那契数 - 力扣（LeetCode）](https://leetcode.cn/problems/fibonacci-number/)

> 1 1 2 3 5 8 ......

五部曲:

1. dp数组含义: `dp[i] 就是斐波那契数列第i项的值`
2. 递推公式: `dp[i] = dp[i - 1] + dp[i - 2] 斐波那契数列规定 第n个数等于前面两个数的和`
3. dp初始化: `dp[0] = 1, dp[1] = 1, 斐波那契数列规定前两项为1`
4. 遍历顺序: `从左到右递推`

```js
function fib(n) {
  const dp = new Array(n)
  dp[0] = 1
  dp[1] = 1
  for (let i = 2; i < n; i ++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  
  return dp[n - 1]
}
```

1. 

### 2. [70. 爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/climbing-stairs/)

> 斐波那契数列衍生题目

| 第n阶 |               方法                |
| :---: | :-------------------------------: |
|   1   |              1 (跳1)              |
|   2   |        2 (跳两次1/跳一次2)        |
|   3   | 3 (从1/2上来, 前两项的方法数的和) |
|   4   |  5 (从2/3上来, 前两项的方法数和)  |
|  ...  |                ...                |

```js
function clim(n) {
  const dp = new Array(n)
  dp[0] = 1
  dp[1] = 2
  
  for (let i = 2; i < n; i ++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  
  return dp[n - 1]
}
```

五部曲总结:

与题目1类似



### 3. [746. 使用最小花费爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/min-cost-climbing-stairs/)

五部曲: 

1. dp[i] 代表到达 i 位置所需的花费
2. `dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])`  爬楼梯, 要么从i - 1上来, 要么从i - 2 上来, 加上对应的花费
3. dp[0] = 0, dp[1] = 0 `题目规定: 0位置无需消费体力, 并且可选择0/1作为起点`
4. 从左向右遍历



```js
function minCostClimbingStairs(cost) {
	const n = cost.length
  const dp = new Array(n).fill(0)
  
  for (let i = 2; i <= n; i ++) {
    dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
  }
  
  return dp[n] // 注意是跳到顶部, 就是cost.length + 1的高度才是顶端
}
```

### 4. [62. 不同路径 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths/)

五部曲

1. `dp[i][j]`代表到达`[i][j]`有多少种路径
2. 递推公式: `dp[i][j] = dp[i][j - 1] + dp[i - 1][j]` 要么从上面下来, 要么从左边过来
3. `dp[0][0] = 1, dp[0][1] = 1, dp[1][0] = 1` 原地为1, 向右走一步为1, 向下走一步为1
4. 从左向右



```js
function uniquePaths(m, n) {
  const dp = new Array(m).fill(0).map(_ => new Array(n).fill(1))
  
  for (let i = 1; i < m; i ++) {
    for (let j = 1; j < n; j ++) {
      dp[i][j] = dp[i][j - 1] + dp[i - 1][j]
    }
  }
  
  return dp[m - 1][n - 1]
}
```

### 5. [63. 不同路径 II - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths-ii/)

五部曲:

1. `dp[i][j]`代表到达`[i][j]`有多少种路径
2. 递推公式:  `if (grid[i][j] !== 1) dp[i][j] = dp[i][j - 1] + dp[i - 1][j]` 要么从上面下来, 要么从左边过来, 注意加了一个判断条件, 当前块不是障碍物才可以进行递推
3. 初始化: 注意如果遇到障碍物障碍物后的均为0
4. 从左向右



```js
function uniquePathsWithObstacles(grid) {
  const m = grid.length
  const n = grid[0].length
  
  const dp = new Array(m).fill(0).map(_ => new Array(n).fill(0))

	for (let i = 0; i < m  && grid[i][0] !== 1; i ++) {
    dp[i][0] = 1
  }

  for (let j = 0; j < n  && grid[0][j] !== 1; j ++) {
    dp[0][j] = 1
  }
  
  for (let i = 1; i < m; i ++) {
    for (let j = 1; j < n; j ++) {
      if (grid[i][j] !== 1) dp[i][j] = dp[i][j - 1] + dp[i - 1][j]
    }
  }
  
  return dp[m - 1][n - 1]
}
```



### 6. [343. 整数拆分 - 力扣（LeetCode）](https://leetcode.cn/problems/integer-break/)

五部曲

1. `dp[i]` 对 `i`进行拆分, 得到的最大乘积
2. `dp[i] = Math.max(j * (i - j), j * dp[i - j], dp[i])` i 代表当前数字, j代表比 i / 2 小的数进行拆分, j * i - j 代表拆分一次, dp[i - j] 代表对i - j的拆分
3. 由题意可得: `dp[0] = 0, dp[1] = 0, dp[2] = 1`
4. 从左向右遍历

```js
function integerBreak(n) {
  const dp = new Array(n + 1).fill(0)
  dp[0] = 0
  dp[1] = 0
  dp[2] = 1
  
  for (let i = 3; i <= n; i ++) {
    for (let j = 1; j <= (i >> 1); j ++) {
      dp[i] = Math.max(j * (i - j), j * dp[i - j], dp[i])
    }
  }

  return dp[n]
}
```

### 7. [96. 不同的二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-binary-search-trees/)

五部曲: 

1. `dp[i]`代表节点为n的有多少种二叉搜索树
2. 状态转移方程: `dp[i] += dp[i - j] * dp[j - 1]` i代表节点数, j - 1为头结点左子树节点数量, i - j代表以j为头结点右子树的数量
3. 

```js
function numTrees(n) {
  const dp = new Array(n + 1).fill(0)
  dp[0] = 1
  dp[1] = 1
  
  for (let i = 2; i <= n; i ++) {
    for (let j = 1; j <= i; j ++) {
      dp[i] += dp[i - j] * dp[j - 1]
    }
  }
  
  return dp[n]
}
```

### 背包问题

1. 01背包: 每种物品只有1个
2. 完全背包: 每种物品有无限个
3. 多重背包: 每种物品数量各不相同

### 41. [516. 最长回文子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-subsequence/)