## LeetCode 338 比特位计数

先熟悉三个运算符`&` `|` `^` `~`

都是js里面的位运算符

## &
> 位与运算符

| 第一个值 | 第二个值 | 结果 |
| -------- | -------- | ---- |
| 1        | 1        | 1    |
| 1        | 0        | 0    |
| 0        | 1        | 0    |
| 0        | 0        | 0    |

均为1结果为1, 否则为0



## |

> 位或运算符

| 第一个值 | 第二个值 | 结果 |
| -------- | -------- | ---- |
| 1        | 1        | 1    |
| 1        | 0        | 1    |
| 0        | 1        | 1    |
| 0        | 0        | 1    |

两个有一个为1就是1, 否则为0



## ^

> 位异或运算符

| 第一个值 | 第二个值 | 结果 |
| -------- | -------- | ---- |
| 1        | 1        | 0    |
| 1        | 0        | 1    |
| 0        | 1        | 1    |
| 0        | 0        | 0    |

两个不一样返回1, 一样返回0



## ~

> 位非运算符

将数字取负值, 再减去1

```js
const bitNot = n => - n - 1
const isSame = n => ~ n === - n - 1 // 在一定范围内, 总是true
```



回到本问题


i & (i - 1)可以去掉i的二进制最后一个1(如果最后一个是1), i & (i - 1)是比i小的, 而且i & (i - 1)的个数在前面已经算过, 所以, i 的 1 个数就是i&(i-1) + 1


```js
const countBits = num => {
  let ans = new Array(num + 1).fill(0)
  for (let i = 1; i <= num; i ++) {
    ans[i] = ans[i & (i - 1)] + 1
  }
  return ans
}

// 利用这个校验
const number = num => [num, num & (num - 1), num.toString(2), (num & (num - 1)).toString(2)]
```

